{"version":3,"file":"slider.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["/**\n * Welcome to @reach/slider!\n *\n * A UI input component where the user selects a value from within a given\n * range. A Slider has a handle that can be moved along a track to change its\n * value. When the user's mouse or focus is on the Slider's handle, the value\n * can be incremented with keyboard controls.\n *\n * Random thoughts/notes:\n *  - Currently testing this against the behavior of the native input range\n *    element to get our slider on par. We'll explore animated and multi-handle\n *    sliders next.\n *  - We may want to research some use cases for reversed sliders in RTL\n *    languages if that's a thing\n *\n * @see Docs     https://reacttraining.com/reach-ui/slider\n * @see Source   https://github.com/reach/reach-ui/tree/main/packages/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#slider\n * @see Example  https://github.com/Stanko/aria-progress-range-slider\n * @see Example  http://www.oaa-accessibility.org/examplep/slider1/\n */\n\n/* eslint-disable jsx-a11y/no-static-element-interactions */\n\nimport React, {\n  memo,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport PropTypes from \"prop-types\";\nimport { useId } from \"@reach/auto-id\";\nimport {\n  checkStyles,\n  createNamedContext,\n  forwardRefWithAs,\n  getOwnerDocument,\n  isFunction,\n  makeId,\n  memoWithAs,\n  useEventCallback,\n  useForkedRef,\n  useControlledSwitchWarning,\n  useControlledState,\n  useIsomorphicLayoutEffect,\n  warning,\n  wrapEvent,\n  noop,\n} from \"@reach/utils\";\n\n// TODO: Remove in 1.0\nexport type SliderAlignment = \"center\" | \"contain\";\n\nexport enum SliderOrientation {\n  Horizontal = \"horizontal\",\n  Vertical = \"vertical\",\n  // TODO: Add support for RTL slider\n}\n\n// TODO: Remove in 1.0\nexport enum SliderHandleAlignment {\n  // Handle is centered directly over the current value marker\n  Center = \"center\",\n  // Handle is contained within the bounds of the track, offset slightly from\n  // the value's center mark to accommodate\n  Contain = \"contain\",\n}\n\n// TODO: Remove in 1.0\nexport const SLIDER_ORIENTATION_HORIZONTAL = SliderOrientation.Horizontal;\nexport const SLIDER_ORIENTATION_VERTICAL = SliderOrientation.Vertical;\nexport const SLIDER_HANDLE_ALIGN_CENTER = SliderHandleAlignment.Center;\nexport const SLIDER_HANDLE_ALIGN_CONTAIN = SliderHandleAlignment.Contain;\n\nconst SliderContext = createNamedContext<ISliderContext>(\n  \"SliderContext\",\n  {} as ISliderContext\n);\nconst useSliderContext = () => useContext(SliderContext);\n\n// These proptypes are shared between the composed SliderInput component and the\n// simplified Slider\nconst sliderPropTypes = {\n  defaultValue: PropTypes.number,\n  disabled: PropTypes.bool,\n  getAriaLabel: PropTypes.func,\n  getAriaValueText: PropTypes.func,\n  getValueText: PropTypes.func,\n  handleAlignment: PropTypes.oneOf([\n    SliderHandleAlignment.Center,\n    SliderHandleAlignment.Contain,\n  ]),\n  min: PropTypes.number,\n  max: PropTypes.number,\n  name: PropTypes.string,\n  orientation: PropTypes.oneOf([\n    SliderOrientation.Horizontal,\n    SliderOrientation.Vertical,\n  ]),\n  onChange: PropTypes.func,\n  step: PropTypes.number,\n  value: PropTypes.number,\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Slider\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#slider\n */\nconst Slider = forwardRefWithAs<SliderProps, \"div\">(function Slider(\n  { children, ...props },\n  forwardedRef\n) {\n  return (\n    <SliderInput\n      {...props}\n      ref={forwardedRef}\n      data-reach-slider=\"\"\n      _componentName=\"Slider\"\n    >\n      <SliderTrack>\n        <SliderTrackHighlight />\n        <SliderHandle />\n        {children}\n      </SliderTrack>\n    </SliderInput>\n  );\n});\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/slider#slider-props\n */\nexport type SliderProps = {\n  /**\n   * `Slider` can accept `SliderMarker` children to enhance display of specific\n   * values along the track.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-children\n   */\n  children?: React.ReactNode;\n  /**\n   * The defaultValue is used to set an initial value for an uncontrolled\n   * Slider.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-defaultvalue\n   */\n  defaultValue?: number;\n  /**\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-disabled\n   */\n  disabled?: boolean;\n  /**\n   * Whether or not the slider should be disabled from user interaction.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-value\n   */\n  value?: number;\n  /**\n   * A function used to set a human-readable name for the slider.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-getarialabel\n   */\n  getAriaLabel?(value: number): string;\n  /**\n   * A function used to set a human-readable value text based on the slider's\n   * current value.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-getariavaluetext\n   */\n  getAriaValueText?(value: number): string;\n  /**\n   * Deprecated. Use `getAriaValueText` instead.\n   *\n   * @deprecated\n   * @param value\n   */\n  getValueText?(value: number): string;\n  /**\n   * When set to `center`, the slider's handle will be positioned directly\n   * centered over the slider's curremt value on the track. This means that when\n   * the slider is at its min or max value, a visiable slider handle will extend\n   * beyond the width (or height in vertical mode) of the slider track. When set\n   * to `contain`, the slider handle will always be contained within the bounds\n   * of the track, meaning its position will be slightly offset from the actual\n   * value depending on where it sits on the track.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-handlealignment\n   */\n  handleAlignment?: \"center\" | \"contain\" | SliderAlignment;\n  /**\n   * The maximum value of the slider. Defaults to `100`.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-max\n   */\n  max?: number;\n  /**\n   * The minimum value of the slider. Defaults to `0`.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-min\n   */\n  min?: number;\n  /**\n   * If the slider is used as a form input, it should accept a `name` prop to\n   * identify its value in context of the form.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-name\n   */\n  name?: string;\n  /**\n   * Callback that fires when the slider value changes. When the `value` prop is\n   * set, the Slider state becomes controlled and `onChange` must be used to\n   * update the value in response to user interaction.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-onchange\n   */\n  onChange?(\n    newValue: number,\n    props?: {\n      min?: number;\n      max?: number;\n      handlePosition?: string;\n    }\n  ): void;\n\n  // We use native DOM events for the slider since they are global\n  onMouseDown?(event: MouseEvent): void;\n  onMouseMove?(event: MouseEvent): void;\n  onMouseUp?(event: MouseEvent): void;\n  onPointerDown?(event: PointerEvent): void;\n  onPointerUp?(event: PointerEvent): void;\n  onTouchEnd?(event: TouchEvent): void;\n  onTouchMove?(event: TouchEvent): void;\n  onTouchStart?(event: TouchEvent): void;\n\n  /**\n   * Sets the slider to horizontal or vertical mode.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-orientation\n   */\n  orientation?: SliderOrientation;\n  /**\n   * The step attribute is a number that specifies the granularity that the\n   * value must adhere to as it changes. Step sets minimum intervals of change,\n   * creating a \"snap\" effect when the handle is moved along the track.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-step\n   */\n  step?: number;\n};\n\nif (__DEV__) {\n  Slider.displayName = \"Slider\";\n  Slider.propTypes = {\n    ...sliderPropTypes,\n    children: PropTypes.node,\n  };\n}\n\nexport { Slider };\nexport default Slider;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * SliderInput\n *\n * The parent component of the slider interface. This is a lower level component\n * if you need more control over styles or rendering the slider's inner\n * components.\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#sliderinput\n */\nconst SliderInput = forwardRefWithAs<\n  SliderInputProps & { _componentName?: string }\n>(function SliderInput(\n  {\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-valuetext\": ariaValueTextProp,\n    as: Comp = \"div\",\n    defaultValue,\n    disabled = false,\n    value: controlledValue,\n    getAriaLabel,\n    getAriaValueText,\n    getValueText: DEPRECATED_getValueText, // TODO: Remove in 1.0\n    handleAlignment = SliderHandleAlignment.Center,\n    max = 100,\n    min = 0,\n    name,\n    onChange,\n    onKeyDown,\n    onMouseDown,\n    onMouseMove,\n    onMouseUp,\n    onPointerDown,\n    onPointerUp,\n    onTouchEnd,\n    onTouchMove,\n    onTouchStart,\n    orientation = SliderOrientation.Horizontal,\n    step = 1,\n    children,\n    _componentName = \"SliderInput\",\n    ...rest\n  },\n  forwardedRef\n) {\n  useControlledSwitchWarning(controlledValue, \"value\", _componentName);\n\n  warning(\n    !DEPRECATED_getValueText,\n    \"The `getValueText` prop in @reach/slider is deprecated. Please use `getAriaValueText` instead.\"\n  );\n\n  let touchId: TouchIdRef = useRef();\n\n  let id = useId(rest.id);\n\n  // Track whether or not the pointer is down without updating the component\n  let pointerDownRef = useRef(false);\n\n  let trackRef: TrackRef = useRef(null);\n  let handleRef: HandleRef = useRef(null);\n  let sliderRef: SliderRef = useRef(null);\n  let ref = useForkedRef(sliderRef, forwardedRef);\n\n  let [hasFocus, setHasFocus] = useState(false);\n\n  let { ref: x, ...handleDimensions } = useDimensions(handleRef);\n\n  let [_value, setValue] = useControlledState(\n    controlledValue,\n    defaultValue || min\n  );\n  let value = clamp(_value, min, max);\n  let trackPercent = valueToPercent(value, min, max);\n  let isVertical = orientation === SliderOrientation.Vertical;\n\n  let handleSize = isVertical\n    ? handleDimensions.height\n    : handleDimensions.width;\n\n  // TODO: Consider removing the `handleAlignment` prop\n  // We may want to use accept a `handlePosition` prop instead and let apps\n  // define their own positioning logic, similar to how we do for popovers.\n  let handlePosition = `calc(${trackPercent}% - ${\n    handleAlignment === SliderHandleAlignment.Center\n      ? `${handleSize}px / 2`\n      : `${handleSize}px * ${trackPercent * 0.01}`\n  })`;\n  let handlePositionRef = useRef(handlePosition);\n  useIsomorphicLayoutEffect(() => {\n    handlePositionRef.current = handlePosition;\n  }, [handlePosition]);\n\n  let onChangeRef = useRef(onChange);\n  useIsomorphicLayoutEffect(() => {\n    onChangeRef.current = onChange;\n  }, [onChange]);\n  let updateValue = useCallback(\n    function updateValue(newValue) {\n      setValue(newValue);\n      if (onChangeRef.current) {\n        // Prevent onChange from recreating the function\n        // TODO: Reonsider the onChange callback API\n        onChangeRef.current(newValue, {\n          min,\n          max,\n          // Prevent handlePosition from recreating the function\n          handlePosition: handlePositionRef.current,\n        });\n      }\n    },\n    [max, min, setValue]\n  );\n\n  let getNewValueFromEvent = useCallback(\n    (event: SomePointerEvent) => {\n      return getNewValue(getPointerPosition(event, touchId), trackRef.current, {\n        step,\n        orientation,\n        min,\n        max,\n      });\n    },\n    [max, min, orientation, step]\n  );\n\n  // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_kbd_interaction\n  let handleKeyDown = useEventCallback((event: React.KeyboardEvent) => {\n    if (disabled) {\n      return;\n    }\n\n    let newValue: number;\n    let tenSteps = (max - min) / 10;\n    let keyStep = step || (max - min) / 100;\n\n    switch (event.key) {\n      // Decrease the value of the slider by one step.\n      case \"ArrowLeft\":\n      case \"ArrowDown\":\n        newValue = value - keyStep;\n        break;\n      // Increase the value of the slider by one step\n      case \"ArrowRight\":\n      case \"ArrowUp\":\n        newValue = value + keyStep;\n        break;\n      // Decrement the slider by an amount larger than the step change made by\n      // `ArrowDown`.\n      case \"PageDown\":\n        newValue = value - tenSteps;\n        break;\n      // Increment the slider by an amount larger than the step change made by\n      // `ArrowUp`.\n      case \"PageUp\":\n        newValue = value + tenSteps;\n        break;\n      // Set the slider to the first allowed value in its range.\n      case \"Home\":\n        newValue = min;\n        break;\n      // Set the slider to the last allowed value in its range.\n      case \"End\":\n        newValue = max;\n        break;\n      default:\n        return;\n    }\n\n    event.preventDefault();\n    newValue = clamp(\n      step ? roundValueToStep(newValue, step, min) : newValue,\n      min,\n      max\n    );\n    updateValue(newValue);\n  });\n\n  let ariaValueText = DEPRECATED_getValueText\n    ? DEPRECATED_getValueText(value)\n    : getAriaValueText\n    ? getAriaValueText(value)\n    : ariaValueTextProp;\n\n  let trackHighlightStyle = isVertical\n    ? {\n        width: `100%`,\n        height: `${trackPercent}%`,\n        bottom: 0,\n      }\n    : {\n        width: `${trackPercent}%`,\n        height: `100%`,\n        left: 0,\n      };\n\n  let ctx: ISliderContext = {\n    ariaLabel: getAriaLabel ? getAriaLabel(value) : ariaLabel,\n    ariaLabelledBy,\n    ariaValueText,\n    handleDimensions,\n    handleKeyDown,\n    handlePosition,\n    handleRef,\n    hasFocus,\n    onKeyDown,\n    setHasFocus,\n    sliderId: id,\n    sliderMax: max,\n    sliderMin: min,\n    value,\n    disabled: !!disabled,\n    isVertical,\n    orientation,\n    trackPercent,\n    trackRef,\n    trackHighlightStyle,\n    updateValue,\n  };\n\n  // Slide events!\n  // We will try to use pointer events if they are supported to leverage\n  // setPointerCapture and releasePointerCapture. We'll fall back to separate\n  // mouse and touch events.\n  // TODO: This could be more concise\n  let removeMoveEvents = useRef<() => void>(noop);\n  let removeStartEvents = useRef<() => void>(noop);\n  let removeEndEvents = useRef<() => void>(noop);\n\n  // Store our event handlers in refs so we aren't attaching/detaching events\n  // on every render if the user doesn't useCallback\n  let appEvents = useRef({\n    onMouseMove,\n    onMouseDown,\n    onMouseUp,\n    onTouchStart,\n    onTouchEnd,\n    onTouchMove,\n    onPointerDown,\n    onPointerUp,\n  });\n  useIsomorphicLayoutEffect(() => {\n    appEvents.current.onMouseMove = onMouseMove;\n    appEvents.current.onMouseDown = onMouseDown;\n    appEvents.current.onMouseUp = onMouseUp;\n    appEvents.current.onTouchStart = onTouchStart;\n    appEvents.current.onTouchEnd = onTouchEnd;\n    appEvents.current.onTouchMove = onTouchMove;\n    appEvents.current.onPointerDown = onPointerDown;\n    appEvents.current.onPointerUp = onPointerUp;\n  }, [onMouseMove, onMouseDown, onMouseUp, onTouchStart, onTouchEnd, onTouchMove, onPointerDown, onPointerUp]);\n\n  let handleSlideStart = useEventCallback((event: SomePointerEvent) => {\n    if (disabled) {\n      pointerDownRef.current = false;\n      return;\n    }\n\n    pointerDownRef.current = true;\n\n    if ((event as TouchEvent).changedTouches) {\n      // Prevent scrolling for touch events\n      event.preventDefault();\n      let touch = (event as TouchEvent).changedTouches?.[0];\n      if (touch != null) {\n        touchId.current = touch.identifier;\n      }\n    }\n\n    let newValue = getNewValueFromEvent(event);\n    if (newValue == null) {\n      return;\n    }\n    handleRef.current?.focus();\n    updateValue(newValue);\n\n    removeMoveEvents.current = addMoveListener();\n    removeEndEvents.current = addEndListener();\n  });\n\n  let setPointerCapture = useEventCallback((event: PointerEvent) => {\n    if (disabled) {\n      pointerDownRef.current = false;\n      return;\n    }\n    pointerDownRef.current = true;\n    sliderRef.current?.setPointerCapture(event.pointerId);\n  });\n\n  let releasePointerCapture = useEventCallback((event: PointerEvent) => {\n    sliderRef.current?.releasePointerCapture(event.pointerId);\n    pointerDownRef.current = false;\n  });\n\n  let handlePointerMove = useEventCallback((event: SomePointerEvent) => {\n    if (disabled || !pointerDownRef.current) {\n      pointerDownRef.current = false;\n      return;\n    }\n\n    let newValue = getNewValueFromEvent(event);\n    if (newValue == null) {\n      return;\n    }\n    updateValue(newValue);\n  });\n\n  let handleSlideStop = useEventCallback((event: SomePointerEvent) => {\n    pointerDownRef.current = false;\n\n    let newValue = getNewValueFromEvent(event);\n    if (newValue == null) {\n      return;\n    }\n\n    touchId.current = undefined;\n\n    removeMoveEvents.current();\n    removeEndEvents.current();\n  });\n\n  let addMoveListener = useCallback(() => {\n    let ownerDocument = getOwnerDocument(sliderRef.current!) || document;\n    let touchListener = wrapEvent(\n      appEvents.current.onTouchMove,\n      handlePointerMove\n    );\n    let mouseListener = wrapEvent(\n      appEvents.current.onMouseMove,\n      handlePointerMove\n    );\n    ownerDocument.addEventListener(\"touchmove\", touchListener);\n    ownerDocument.addEventListener(\"mousemove\", mouseListener);\n    return () => {\n      ownerDocument.removeEventListener(\"touchmove\", touchListener);\n      ownerDocument.removeEventListener(\"mousemove\", mouseListener);\n    };\n  }, [handlePointerMove]);\n\n  let addEndListener = useCallback(() => {\n    let ownerDocument = getOwnerDocument(sliderRef.current!) || document;\n    let pointerListener = wrapEvent(\n      appEvents.current.onPointerUp,\n      releasePointerCapture\n    );\n    let touchListener = wrapEvent(\n      appEvents.current.onTouchEnd,\n      handleSlideStop\n    );\n    let mouseListener = wrapEvent(appEvents.current.onMouseUp, handleSlideStop);\n    if (\"PointerEvent\" in window) {\n      ownerDocument.addEventListener(\"pointerup\", pointerListener);\n    }\n    ownerDocument.addEventListener(\"touchend\", touchListener);\n    ownerDocument.addEventListener(\"mouseup\", mouseListener);\n    return () => {\n      if (\"PointerEvent\" in window) {\n        ownerDocument.removeEventListener(\"pointerup\", pointerListener);\n      }\n      ownerDocument.removeEventListener(\"touchend\", touchListener);\n      ownerDocument.removeEventListener(\"mouseup\", mouseListener);\n    };\n  }, [handleSlideStop, releasePointerCapture]);\n\n  let addStartListener = useCallback(() => {\n    let touchListener = wrapEvent(\n      appEvents.current.onTouchStart,\n      handleSlideStart\n    );\n    let mouseListener = wrapEvent(\n      appEvents.current.onMouseDown,\n      handleSlideStart\n    );\n    let pointerListener = wrapEvent(\n      appEvents.current.onPointerDown,\n      setPointerCapture\n    );\n\n    // e.preventDefault is ignored by React's synthetic touchStart event, so\n    // we attach the listener directly to the DOM node\n    // https://github.com/facebook/react/issues/9809#issuecomment-413978405\n    sliderRef.current!.addEventListener(\"touchstart\", touchListener);\n    sliderRef.current!.addEventListener(\"mousedown\", mouseListener);\n    if (\"PointerEvent\" in window) {\n      sliderRef.current!.addEventListener(\"pointerdown\", pointerListener);\n    }\n    return () => {\n      sliderRef.current!.removeEventListener(\"touchstart\", touchListener);\n      sliderRef.current!.removeEventListener(\"mousedown\", mouseListener);\n      if (\"PointerEvent\" in window) {\n        sliderRef.current!.removeEventListener(\"pointerdown\", pointerListener);\n      }\n    };\n  }, [setPointerCapture, handleSlideStart]);\n\n  useEffect(() => {\n    removeStartEvents.current = addStartListener();\n\n    return () => {\n      removeStartEvents.current();\n      removeEndEvents.current();\n      removeMoveEvents.current();\n    };\n  }, [addStartListener]);\n\n  useEffect(() => checkStyles(\"slider\"), []);\n\n  return (\n    <SliderContext.Provider value={ctx}>\n      <Comp\n        {...rest}\n        ref={ref}\n        data-reach-slider-input=\"\"\n        data-disabled={disabled ? \"\" : undefined}\n        data-orientation={orientation}\n        tabIndex={-1}\n      >\n        {isFunction(children)\n          ? children({\n              hasFocus,\n              id,\n              max,\n              min,\n              value,\n              ariaValueText,\n              valueText: ariaValueText, // TODO: Remove in 1.0\n            })\n          : children}\n        {name && (\n          // If the slider is used in a form we'll need an input field to\n          // capture the value. We'll assume this when the component is given a\n          // form field name (A `name` prop doesn't really make sense in any\n          // other context).\n          <input\n            type=\"hidden\"\n            value={value}\n            name={name}\n            id={id && makeId(\"input\", id)}\n          />\n        )}\n      </Comp>\n    </SliderContext.Provider>\n  );\n});\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/slider#sliderinput-props\n */\nexport type SliderInputProps = Omit<SliderProps, \"children\"> & {\n  /**\n   * Slider expects `<SliderTrack>` as its child; The track will accept all\n   * additional slider sub-components as children. It can also accept a\n   * function/render prop as its child to expose some of its internal state\n   * variables.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#sliderinput-children\n   */\n  children: React.ReactNode | SliderChildrenRender;\n};\n\nif (__DEV__) {\n  SliderInput.displayName = \"SliderInput\";\n  SliderInput.propTypes = {\n    ...sliderPropTypes,\n    children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n  };\n}\n\nexport { SliderInput };\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * SliderTrack\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#slidertrack\n */\nconst SliderTrackImpl = forwardRefWithAs<SliderTrackProps>(function SliderTrack(\n  { as: Comp = \"div\", children, style = {}, ...props },\n  forwardedRef\n) {\n  const { disabled, orientation, trackRef } = useSliderContext();\n  const ref = useForkedRef(trackRef, forwardedRef);\n\n  return (\n    <Comp\n      ref={ref}\n      style={{ ...style, position: \"relative\" }}\n      {...props}\n      data-reach-slider-track=\"\"\n      data-disabled={disabled ? \"\" : undefined}\n      data-orientation={orientation}\n    >\n      {children}\n    </Comp>\n  );\n});\n\nif (__DEV__) {\n  SliderTrackImpl.displayName = \"SliderTrack\";\n  SliderTrackImpl.propTypes = {\n    children: PropTypes.node.isRequired,\n  };\n}\n\nconst SliderTrack = memoWithAs(SliderTrackImpl);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/slider#slidertrack-props\n */\nexport type SliderTrackProps = {\n  /**\n   * `SliderTrack` expects `<SliderHandle>`, at minimum, for the Slider to\n   * function. All other Slider subcomponents should be passed as children\n   * inside the `SliderTrack`.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slidertrack-children\n   */\n  children: React.ReactNode;\n};\n\nif (__DEV__) {\n  SliderTrack.displayName = \"SliderTrack\";\n}\n\nexport { SliderTrack };\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * SliderTrackHighlight\n *\n * The (typically) highlighted portion of the track that represents the space\n * between the slider's `min` value and its current value.\n *\n * TODO: Consider renaming to `SliderTrackProgress`\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#slidertrackhighlight\n */\nconst SliderTrackHighlightImpl = forwardRefWithAs<SliderTrackHighlightProps>(\n  function SliderTrackHighlight(\n    { as: Comp = \"div\", children, style = {}, ...props },\n    forwardedRef\n  ) {\n    let { disabled, orientation, trackHighlightStyle } = useSliderContext();\n    return (\n      <Comp\n        ref={forwardedRef}\n        style={{ position: \"absolute\", ...trackHighlightStyle, ...style }}\n        {...props}\n        data-reach-slider-track-highlight=\"\"\n        data-disabled={disabled ? \"\" : undefined}\n        data-orientation={orientation}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  SliderTrackHighlightImpl.displayName = \"SliderTrackHighlight\";\n  SliderTrackHighlightImpl.propTypes = {};\n}\n\nconst SliderTrackHighlight = memoWithAs(SliderTrackHighlightImpl);\n\n/**\n * `SliderTrackHighlight` accepts any props that a HTML div component accepts.\n * `SliderTrackHighlight` will not accept or render any children.\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#slidertrackhighlight-props\n */\nexport type SliderTrackHighlightProps = {};\n\nif (__DEV__) {\n  SliderTrackHighlight.displayName = \"SliderTrackHighlight\";\n}\n\nexport { SliderTrackHighlight };\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * SliderHandle\n *\n * The handle that the user drags along the track to set the slider value.\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#sliderhandle\n */\nconst SliderHandleImpl = forwardRefWithAs<SliderHandleProps>(\n  function SliderHandle(\n    {\n      // min,\n      // max,\n      as: Comp = \"div\",\n      onBlur,\n      onFocus,\n      style = {},\n      onKeyDown,\n      ...props\n    },\n    forwardedRef\n  ) {\n    const {\n      ariaLabel,\n      ariaLabelledBy,\n      ariaValueText,\n      disabled,\n      handlePosition,\n      handleRef,\n      isVertical,\n      handleKeyDown,\n      orientation,\n      setHasFocus,\n      sliderMin,\n      sliderMax,\n      value,\n    } = useSliderContext();\n\n    const ref = useForkedRef(handleRef, forwardedRef);\n\n    return (\n      <Comp\n        aria-disabled={disabled || undefined}\n        // If the slider has a visible label, it is referenced by\n        // `aria-labelledby` on the slider element. Otherwise, the slider\n        // element has a label provided by `aria-label`.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabel ? undefined : ariaLabelledBy}\n        // If the slider is vertically oriented, it has `aria-orientation` set\n        // to vertical. The default value of `aria-orientation` for a slider is\n        // horizontal.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-orientation={orientation}\n        // The slider element has the `aria-valuemax` property set to a decimal\n        // value representing the maximum allowed value of the slider.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-valuemax={sliderMax}\n        // The slider element has the `aria-valuemin` property set to a decimal\n        // value representing the minimum allowed value of the slider.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-valuemin={sliderMin}\n        // The slider element has the `aria-valuenow` property set to a decimal\n        // value representing the current value of the slider.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-valuenow={value}\n        // If the value of `aria-valuenow` is not user-friendly, e.g., the day\n        // of the week is represented by a number, the `aria-valuetext` property\n        // is set to a string that makes the slider value understandable, e.g.,\n        // \"Monday\".\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-valuetext={ariaValueText}\n        // The element serving as the focusable slider control has role\n        // `slider`.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        role=\"slider\"\n        tabIndex={disabled ? -1 : 0}\n        {...props}\n        data-reach-slider-handle=\"\"\n        ref={ref}\n        onBlur={wrapEvent(onBlur, () => {\n          setHasFocus(false);\n        })}\n        onFocus={wrapEvent(onFocus, () => {\n          setHasFocus(true);\n        })}\n        onKeyDown={wrapEvent(onKeyDown, handleKeyDown)}\n        style={{\n          position: \"absolute\",\n          ...(isVertical\n            ? { bottom: handlePosition }\n            : { left: handlePosition }),\n          ...style,\n        }}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  SliderHandleImpl.displayName = \"SliderHandle\";\n  SliderHandleImpl.propTypes = {};\n}\n\nconst SliderHandle = memoWithAs(SliderHandleImpl);\n\n/**\n * `SliderTrackHighlight` accepts any props that a HTML div component accepts.\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#sliderhandle-props\n */\nexport type SliderHandleProps = {};\n\nif (__DEV__) {\n  SliderHandle.displayName = \"SliderHandle\";\n}\n\nexport { SliderHandle };\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * SliderMarker\n *\n * A fixed value marker. These can be used to illustrate a range of steps or\n * highlight important points along the slider track.\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#slidermarker\n */\nconst SliderMarkerImpl = forwardRefWithAs<SliderMarkerProps>(\n  function SliderMarker(\n    { as: Comp = \"div\", children, style = {}, value, ...props },\n    forwardedRef\n  ) {\n    const {\n      disabled,\n      isVertical,\n      orientation,\n      sliderMin,\n      sliderMax,\n      value: sliderValue,\n    } = useSliderContext();\n\n    let inRange = !(value < sliderMin || value > sliderMax);\n    let absoluteStartPosition = `${valueToPercent(\n      value,\n      sliderMin,\n      sliderMax\n    )}%`;\n\n    let state =\n      value < sliderValue\n        ? \"under-value\"\n        : value === sliderValue\n        ? \"at-value\"\n        : \"over-value\";\n\n    return inRange ? (\n      <Comp\n        ref={forwardedRef}\n        style={{\n          position: \"absolute\",\n          ...(isVertical\n            ? { bottom: absoluteStartPosition }\n            : { left: absoluteStartPosition }),\n          ...style,\n        }}\n        {...props}\n        data-reach-slider-marker=\"\"\n        data-disabled={disabled ? \"\" : undefined}\n        data-orientation={orientation}\n        data-state={state}\n        data-value={value}\n        children={children}\n      />\n    ) : null;\n  }\n);\n\nif (__DEV__) {\n  SliderMarkerImpl.displayName = \"SliderMarker\";\n  SliderMarkerImpl.propTypes = {\n    value: PropTypes.number.isRequired,\n  };\n}\n\nconst SliderMarker = memoWithAs(SliderMarkerImpl);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/slider#slidermarker-props\n */\nexport type SliderMarkerProps = {\n  /**\n   * The value to denote where the marker should appear along the track.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slidermarker-value\n   */\n  value: number;\n};\n\nif (__DEV__) {\n  SliderMarker.displayName = \"SliderMarker\";\n}\n\nexport { SliderMarker };\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(val: number, min: number, max: number) {\n  return val > max ? max : val < min ? min : val;\n}\n\n/**\n * This handles the case when num is very small (0.00000001), js will turn\n * this into 1e-8. When num is bigger than 1 or less than -1 it won't get\n * converted to this notation so it's fine.\n *\n * @param num\n * @see https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/Slider/Slider.js#L69\n */\nfunction getDecimalPrecision(num: number) {\n  if (Math.abs(num) < 1) {\n    const parts = num.toExponential().split(\"e-\");\n    const matissaDecimalPart = parts[0].split(\".\")[1];\n    return (\n      (matissaDecimalPart ? matissaDecimalPart.length : 0) +\n      parseInt(parts[1], 10)\n    );\n  }\n\n  const decimalPart = num.toString().split(\".\")[1];\n  return decimalPart ? decimalPart.length : 0;\n}\n\nfunction percentToValue(percent: number, min: number, max: number) {\n  return (max - min) * percent + min;\n}\n\nfunction roundValueToStep(value: number, step: number, min: number) {\n  let nearest = Math.round((value - min) / step) * step + min;\n  return Number(nearest.toFixed(getDecimalPrecision(step)));\n}\n\nfunction getPointerPosition(event: SomePointerEvent, touchId: TouchIdRef) {\n  if (touchId.current !== undefined && (event as TouchEvent).changedTouches) {\n    for (let i = 0; i < (event as TouchEvent).changedTouches.length; i += 1) {\n      const touch = (event as TouchEvent).changedTouches[i];\n      if (touch.identifier === touchId.current) {\n        return {\n          x: touch.clientX,\n          y: touch.clientY,\n        };\n      }\n    }\n\n    return false;\n  }\n\n  return {\n    x: (event as PointerEvent | MouseEvent).clientX,\n    y: (event as PointerEvent | MouseEvent).clientY,\n  };\n}\n\nfunction getNewValue(\n  handlePosition:\n    | {\n        x: number;\n        y: number;\n      }\n    | false,\n  track: HTMLElement | null,\n  props: {\n    orientation: SliderOrientation;\n    min: number;\n    max: number;\n    step?: number;\n  }\n) {\n  let { orientation, min, max, step } = props;\n\n  if (!track || !handlePosition) {\n    return null;\n  }\n\n  let { left, width, bottom, height } = track.getBoundingClientRect();\n  let isVertical = orientation === SliderOrientation.Vertical;\n  let diff = isVertical ? bottom - handlePosition.y : handlePosition.x - left;\n  let percent = diff / (isVertical ? height : width);\n  let newValue = percentToValue(percent, min, max);\n\n  return clamp(\n    step ? roundValueToStep(newValue, step, min) : newValue,\n    min,\n    max\n  );\n}\n\nfunction useDimensions(ref: React.RefObject<HTMLElement | null>) {\n  const [{ width, height }, setDimensions] = useState({ width: 0, height: 0 });\n  // Many existing `useDimensions` type hooks will use `getBoundingClientRect`\n  // getBoundingClientRect does not work here when borders are applied.\n  // getComputedStyle is not as performant so we may want to create a utility to\n  // check for any conflicts with box sizing first and only use\n  // `getComputedStyle` if neccessary.\n  /* const { width, height } = ref.current\n    ? ref.current.getBoundingClientRect()\n    : 0; */\n\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current) {\n      const { height: _newHeight, width: _newWidth } = window.getComputedStyle(\n        ref.current\n      );\n      let newHeight = parseFloat(_newHeight);\n      let newWidth = parseFloat(_newWidth);\n\n      if (newHeight !== height || newWidth !== width) {\n        setDimensions({ height: newHeight, width: newWidth });\n      }\n    }\n  }, [ref, width, height]);\n  return { ref, width, height };\n}\n\nfunction valueToPercent(value: number, min: number, max: number) {\n  return ((value - min) * 100) / (max - min);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype TrackRef = React.RefObject<HTMLDivElement | null>;\ntype HandleRef = React.RefObject<HTMLDivElement | null>;\ntype SliderRef = React.RefObject<HTMLDivElement | null>;\ntype TouchIdRef = React.MutableRefObject<number | undefined>;\n\ntype SomePointerEvent = TouchEvent | MouseEvent;\n\ninterface ISliderContext {\n  ariaLabel: string | undefined;\n  ariaLabelledBy: string | undefined;\n  ariaValueText: string | undefined;\n  handleDimensions: {\n    width: number;\n    height: number;\n  };\n  handlePosition: string;\n  handleRef: HandleRef;\n  hasFocus: boolean;\n  onKeyDown?: (event: React.KeyboardEvent<HTMLDivElement>) => void;\n  handleKeyDown: (event: React.KeyboardEvent<HTMLDivElement>) => void;\n  setHasFocus: React.Dispatch<React.SetStateAction<boolean>>;\n  sliderId: string | undefined;\n  sliderMax: number;\n  sliderMin: number;\n  value: number;\n  disabled: boolean;\n  isVertical: boolean;\n  orientation: SliderOrientation;\n  trackPercent: number;\n  trackRef: TrackRef;\n  trackHighlightStyle: React.CSSProperties;\n  updateValue: (newValue: any) => void;\n}\n\ntype SliderChildrenRender = (props: {\n  ariaValueText?: string | undefined;\n  hasFocus?: boolean;\n  id?: string | undefined;\n  sliderId?: string | undefined;\n  max?: number;\n  min?: number;\n  value?: number;\n  valueText?: string | undefined; // TODO: Remove in 1.0\n}) => JSX.Element;\n"],"names":["SliderOrientation","SliderHandleAlignment","SLIDER_ORIENTATION_HORIZONTAL","Horizontal","SLIDER_ORIENTATION_VERTICAL","Vertical","SLIDER_HANDLE_ALIGN_CENTER","Center","SLIDER_HANDLE_ALIGN_CONTAIN","Contain","SliderContext","createNamedContext","useSliderContext","useContext","Slider","forwardRefWithAs","forwardedRef","children","props","React","SliderInput","ref","_componentName","SliderTrack","SliderTrackHighlight","SliderHandle","ariaLabel","ariaLabelledBy","ariaValueTextProp","as","Comp","defaultValue","disabled","controlledValue","value","getAriaLabel","getAriaValueText","DEPRECATED_getValueText","getValueText","handleAlignment","max","min","name","onChange","onKeyDown","onMouseDown","onMouseMove","onMouseUp","onPointerDown","onPointerUp","onTouchEnd","onTouchMove","onTouchStart","orientation","step","rest","useControlledSwitchWarning","touchId","useRef","id","useId","pointerDownRef","trackRef","handleRef","sliderRef","useForkedRef","useState","hasFocus","setHasFocus","handleDimensions","width","height","setDimensions","useIsomorphicLayoutEffect","current","window","getComputedStyle","_newWidth","newHeight","parseFloat","newWidth","useDimensions","useControlledState","setValue","clamp","trackPercent","valueToPercent","isVertical","handleSize","handlePosition","handlePositionRef","onChangeRef","updateValue","useCallback","newValue","getNewValueFromEvent","event","track","getBoundingClientRect","percent","percentToValue","bottom","y","x","left","roundValueToStep","getNewValue","undefined","changedTouches","i","length","touch","identifier","clientX","clientY","getPointerPosition","handleKeyDown","useEventCallback","tenSteps","keyStep","key","preventDefault","ariaValueText","trackHighlightStyle","ctx","sliderId","sliderMax","sliderMin","removeMoveEvents","noop","removeStartEvents","removeEndEvents","appEvents","handleSlideStart","_event$changedTouches","focus","addMoveListener","addEndListener","setPointerCapture","pointerId","releasePointerCapture","handlePointerMove","handleSlideStop","ownerDocument","getOwnerDocument","document","touchListener","wrapEvent","mouseListener","addEventListener","removeEventListener","pointerListener","addStartListener","useEffect","checkStyles","Provider","tabIndex","isFunction","valueText","type","makeId","SliderTrackImpl","style","position","memoWithAs","SliderHandleImpl","onBlur","onFocus","role","SliderMarker","sliderValue","inRange","absoluteStartPosition","state","val","nearest","Math","round","Number","toFixed","num","abs","parts","toExponential","split","matissaDecimalPart","parseInt","decimalPart","toString","getDecimalPrecision"],"mappings":"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"}